extends RefCounted
## GDScript is created with static funcs that are used in the tween to get properties.
## This lets us "mutate" at runtime, allowing for randomization and lerping towards properties that changes since the tween was created.

static var REGEX_ROOT := RegEx.create_from_string(r'@(?=(?:[A-Za-z_]|[%~][A-Za-z_]))')
static var REGEX_NODE := RegEx.create_from_string(r'\^(?=(?:[A-Za-z_]|[%~][A-Za-z_]))')

var _source_code: String
var _methods: Dictionary
var _return_methods: Dictionary

func _init():
	## !signal_args
	## ~initial_state
	## @node
	_source_code = "#WARNING: AUTOGENERATED - CHANGES WILL BE LOST"+\
		"\nstatic var signal_args: Dictionary"+\
		"\nstatic var initial_state: Dictionary"+\
		"\nstatic var for_nodes: Dictionary"

func create(properties := {}, print_source := false) -> GDScript:
	var head := ""
	var gd := GDScript.new()
	_source_code += "\n# %s" % Time.get_unix_time_from_system()
	gd.source_code = _source_code
	if print_source: print(_source_code)
	gd.reload()
	for prop in properties:
		gd[prop] = properties[prop]
	return gd

func add_static_func(expr: String, returns := true) -> StringName:
	var inpt := expr
	expr = REGEX_ROOT.sub(expr, "root.", true)
	expr = expr.replace("@", "root")
	expr = REGEX_NODE.sub(expr, "node.", true)
	expr = expr.replace("^", "node")
	expr = expr.replace("~", "initial_state[node].")
	
	var h := hash(expr)
	if returns:
		if h in _return_methods:
			return _return_methods[h]
		var method_name := "_rm%s" % len(_return_methods)
		_source_code += "\nstatic func %s(root: Node, node: Node): return %s" % [method_name, expr]
		_return_methods[h] = method_name
		return method_name
	# Compiler gets annoyed if you return stuff for no reason...
	else:
		if h in _methods:
			return _methods[h]
		var method_name := "_m%s" % len(_methods)
		_source_code += "\nstatic func %s(root: Node, node: Node): %s" % [method_name, expr]
		_methods[h] = method_name
		return method_name
